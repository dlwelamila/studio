/**
 * Core Philosophy:
 * This ruleset enforces a user-centric security model with distinct roles for Customers, Helpers,
 * and Admins. The primary goal is Authorization Independence, where a document's authorization
 * data is denormalized directly onto it, preventing slow and costly cross-document `get()` calls.
 * This ensures that security decisions are fast, efficient, and easy to reason about.
 *
 * Data Structure:
 * The data is organized into user-specific data trees and shared top-level collections:
 * - /users/{userId}: Stores public profiles for both Customers and Helpers.
 * - /users/{userId}/tasks/{taskId}: A subcollection containing tasks owned by a specific customer.
 * - /offers/{offerId}: A top-level collection for offers made by Helpers on Tasks.
 * - /ratings/{ratingId}: A top-level collection for public ratings.
 * - /roles_admin/{userId}: A special collection where document existence grants a user admin privileges.
 *
 * Key Security Decisions:
 * - Default Secure: Access is denied unless explicitly granted. Write operations are never public.
 * - User Profiles: User profiles in `/users` are publicly readable to facilitate a marketplace
 *   environment but are writable only by the owner of the profile.
 * - Ownership: Data within a user's tree (e.g., `/users/{userId}/tasks`) is strictly controlled by that user.
 * - Role-Based Access: Admins are granted read-only access to all data for moderation and support
 *   purposes but are restricted from making modifications outside of admin role management. This is a
 *   safe default to prevent accidental data corruption.
 * - Immutability: Certain records, like ratings, are immutable once created.
 *
 * Denormalization for Authorization:
 * This ruleset relies heavily on denormalized fields for authorization. For example, an `Offer`
 * document contains a `helperId`, and a `Task` document contains a `customerId`. This allows rules
 * to verify ownership with a simple check on the document itself (`resource.data.helperId == request.auth.uid`)
 * instead of requiring a `get()` to a parent or related document.
 *
 * Structural Segregation:
 * The separation of user-specific data (e.g., `/users/{userId}/tasks`) into a private subcollection
 * and public data (e.g., `/ratings`) into a top-level collection provides a clear and secure boundary.
 * This allows for safe `list` operations on public data while ensuring private user data cannot be
 * enumerated by unauthorized parties.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to promote readable and reusable rules.

    /**
     * Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the fundamental check for document ownership.
     * @param userId The UID of the user to check for ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the currently authenticated user is an administrator.
     * Admin status is determined by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the user is the helper assigned to a specific task.
     * @param taskData The resource.data of the task document.
     */
    function isAssignedHelper(taskData) {
      return isSignedIn() && taskData.assignedHelperId == request.auth.uid;
    }

    /**
     * Validates that the owner ID field in a document being created matches the creator's UID.
     * @param data The request.resource.data from the incoming document.
     * @param key The name of the ownership field (e.g., 'customerId', 'helperId').
     */
    function isCreatingOwnResource(data, key) {
      return isSignedIn() && data[key] == request.auth.uid;
    }

    /**
     * Validates that an ownership field is immutable on update.
     * @param requestData The request.resource.data from the incoming update.
     * @param resourceData The resource.data from the existing document.
     * @param key The name of the immutable ownership field.
     */
    function ownerFieldIsImmutable(requestData, resourceData, key) {
      return requestData[key] == resourceData[key];
    }

    /**
     * @description
     * User profile documents for both Customers and Helpers.
     * Profiles are public, but only the owner can create, update, or delete their own document.
     * @path /users/{userId}
     * @allow (get) Any user, signed in or not, can view any user's profile.
     * @deny (update) A signed-in user ('user_abc') tries to update the profile of 'user_xyz'.
     * @principle Public read access with strict document ownership for writes.
     */
    match /users/{userId} {
      allow get, list: if true;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource != null && ownerFieldIsImmutable(request.resource.data, resource.data, 'id');
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description
     * Tasks created by a customer, nested under their user document.
     * Only the customer (owner) can manage their tasks. The assigned helper can view the task.
     * @path /users/{customerId}/tasks/{taskId}
     * @allow (get) The customer 'user_abc' reads a task they own.
     * @allow (get) A helper assigned to the task reads its details.
     * @deny (list) An anonymous user tries to list all tasks for 'user_abc'.
     * @deny (update) A helper tries to change the budget of a task they are assigned to.
     * @principle Restricts access to a user's own data tree (ownership pattern).
     */
    match /users/{customerId}/tasks/{taskId} {
      allow get: if isOwner(customerId) || isAssignedHelper(resource.data) || isAdmin();
      allow list: if isOwner(customerId) || isAdmin();
      allow create: if isOwner(customerId) && request.resource.data.customerId == customerId;
      allow update: if isOwner(customerId) && resource != null && ownerFieldIsImmutable(request.resource.data, resource.data, 'customerId');
      allow delete: if isOwner(customerId) && resource != null;
    }

    /**
     * @description
     * Offers made by helpers on tasks.
     * A helper can create, view, update, and delete their own offers.
     * Task owners cannot read offers directly via this rule due to a structural limitation;
     * they would need a denormalized 'customerId' on the offer or a Cloud Function to grant access.
     * Admins can read offers for moderation.
     * @path /offers/{offerId}
     * @allow (create) A signed-in helper ('helper_xyz') creates an offer for a task.
     * @deny (get) A customer tries to read an offer document directly.
     * @deny (list) Any user tries to list all offers in the system.
     * @principle Enforces document ownership for writes and reads, preventing data leakage.
     */
    match /offers/{offerId} {
      allow get: if (resource != null && isOwner(resource.data.helperId)) || isAdmin();
      allow list: if isAdmin();
      allow create: if isCreatingOwnResource(request.resource.data, 'helperId');
      allow update: if resource != null && isOwner(resource.data.helperId) && ownerFieldIsImmutable(request.resource.data, resource.data, 'helperId');
      allow delete: if resource != null && isOwner(resource.data.helperId);
    }

    /**
     * @description
     * Ratings given by customers to helpers.
     * Ratings are public and can be read by anyone. Only the customer involved in the task
     * can create a rating. Ratings are immutable and cannot be updated or deleted.
     * @path /ratings/{ratingId}
     * @allow (list) Any user, signed in or not, can list all ratings.
     * @allow (create) A customer ('user_abc') creates a rating for a completed task.
     * @deny (update) The customer tries to change their rating after submitting it.
     * @principle Public read access with owner-only creation and immutability.
     */
    match /ratings/{ratingId} {
      allow get, list: if true;
      allow create: if isCreatingOwnResource(request.resource.data, 'customerId');
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description
     * Manages administrator roles. The existence of a document in this collection grants
     * a user admin privileges across the application. Only other admins can manage this list.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin adds a new user ('user_xyz') to the admin roles.
     * @deny (list) A non-admin user tries to see the list of all administrators.
     * @deny (delete) A non-admin user tries to remove an admin's role.
     * @principle Secures privileged access control to authorized administrators only.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}