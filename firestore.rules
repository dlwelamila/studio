rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to promote readable and reusable rules.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isApprovedHelper() {
      return isSignedIn()
        && get(/databases/$(database)/documents/helpers/$(request.auth.uid)).data.verificationStatus == 'APPROVED';
    }

    function isAssignedHelper(taskData) {
      return isSignedIn() && taskData.assignedHelperId == request.auth.uid;
    }

    function isResourceOwner(resource, key) {
      return isSignedIn() && resource.data[key] == request.auth.uid;
    }

    function isCreatingOwnResource(key) {
      return isSignedIn() && request.resource.data[key] == request.auth.uid;
    }

    function ownerFieldIsImmutable(key) {
      return request.resource.data[key] == resource.data[key];
    }

    function canUpdateTaskStatus(currentStatus, nextStatus) {
      // Helper transitions
      return (currentStatus == 'ASSIGNED' && nextStatus == 'ACTIVE') ||
             (currentStatus == 'ACTIVE' && nextStatus == 'COMPLETED');
    }

    function customerCanDispute(currentStatus, nextStatus) {
      // Customer transition
      return currentStatus == 'COMPLETED' && nextStatus == 'IN_DISPUTE';
    }

    function customerCanManageTask(currentStatus, nextStatus) {
      // Permit owners to accept an offer, advance work, or dispute completion
      return currentStatus == nextStatus ||
             (currentStatus == 'OPEN' && (nextStatus == 'ASSIGNED' || nextStatus == 'ACCEPTED')) ||
             (currentStatus == 'ASSIGNED' && (nextStatus == 'ACTIVE' || nextStatus == 'OPEN')) ||
             customerCanDispute(currentStatus, nextStatus);
    }

    function helperCanRecordCheckIn() {
      return isAssignedHelper(resource.data) &&
             ownerFieldIsImmutable('customerId') &&
             ownerFieldIsImmutable('assignedHelperId') &&
             request.resource.data.diff(resource.data).changedKeys().hasOnly(['helperCheckInTime']) &&
             request.resource.data.helperCheckInTime is timestamp;
    }

    function helperCanRequestLateStart() {
      return isAssignedHelper(resource.data) &&
             ownerFieldIsImmutable('customerId') &&
             ownerFieldIsImmutable('assignedHelperId') &&
             request.resource.data.diff(resource.data).changedKeys().hasOnly(['lateStartStatus', 'lateStartRequestedAt']) &&
             request.resource.data.lateStartStatus == 'REQUESTED' &&
             request.resource.data.lateStartRequestedAt is timestamp;
    }

    match /customers/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && ownerFieldIsImmutable('id');
      allow delete: if isOwner(userId);
    }

    match /helpers/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && ownerFieldIsImmutable('id');
      allow delete: if isOwner(userId);
    }

    match /tasks/{taskId} {
      allow get: if isSignedIn(); // Let client logic handle what to show
      allow list: if isSignedIn();
      allow create: if isCreatingOwnResource('customerId');

      allow update: if isSignedIn() && (
        // Customer can accept an offer or dispute a completed task
        (isResourceOwner(resource, 'customerId') &&
          ownerFieldIsImmutable('customerId') &&
          customerCanManageTask(resource.data.status, request.resource.data.status)
        ) ||
        // Helper can update status from ASSIGNED -> ACTIVE -> COMPLETED
        (isAssignedHelper(resource.data) &&
          canUpdateTaskStatus(resource.data.status, request.resource.data.status) &&
          ownerFieldIsImmutable('customerId') &&
          ownerFieldIsImmutable('assignedHelperId')) ||
        helperCanRecordCheckIn() ||
        helperCanRequestLateStart()
      );

      allow delete: if isResourceOwner(resource, 'customerId');

      // Offers subcollection
      match /offers/{offerId} {
        allow get, list: if
          isResourceOwner(get(/databases/$(database)/documents/tasks/$(taskId)), 'customerId')
          || isAdmin()
          || isResourceOwner(resource, 'helperId');

        allow create: if isCreatingOwnResource('helperId')
          && isApprovedHelper()
          && request.resource.data.etaAt is timestamp;
        allow update: if (
          isResourceOwner(resource, 'helperId')
            && ownerFieldIsImmutable('helperId')
            && request.resource.data.etaAt is timestamp
        ) || (
          isResourceOwner(get(/databases/$(database)/documents/tasks/$(taskId)), 'customerId')
            && ownerFieldIsImmutable('helperId')
            && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status'])
            && (request.resource.data.status == 'ACCEPTED'
              || request.resource.data.status == 'REJECTED'
              || request.resource.data.status == 'WITHDRAWN'
              || request.resource.data.status == 'SUBMITTED')
        );
        allow delete: if isResourceOwner(resource, 'helperId');
      }
    }

    match /offers/{offerId} {
      allow get, list: if isSignedIn() &&
        (resource.data.helperId == request.auth.uid || isAdmin());
      allow create, update, delete: if false;
    }

    match /ratings/{ratingId} {
      allow get, list: if true;
      allow create: if isCreatingOwnResource('customerId');
      allow update: if false;
      allow delete: if false;
    }

    match /feedbacks/{feedbackId} {
      allow get, list: if true;
      allow create: if isCreatingOwnResource('customerId');
      allow update, delete: if false;
    }

    match /support_tickets/{ticketId} {
      allow get, list, update, delete: if isAdmin();
      allow create: if isCreatingOwnResource('userId');
    }

    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }

    match /task_participants/{participantId} {
      allow get, list: if isSignedIn() && (
        resource.data.customerId == request.auth.uid ||
        resource.data.helperId == request.auth.uid ||
        isAdmin()
      );

      allow create: if isSignedIn() && (
        request.resource.data.helperId == request.auth.uid
      );

      allow update: if isSignedIn() && (
        resource.data.customerId == request.auth.uid ||
        resource.data.helperId == request.auth.uid ||
        isAdmin()
      );

      allow delete: if false;
    }

    match /task_threads/{threadId} {

      function isThreadMember() {
        return isSignedIn() && (
          resource.data.customerId == request.auth.uid ||
          resource.data.helperId == request.auth.uid ||
          (resource.data.members is list &&
            resource.data.members.hasAny([request.auth.uid]))
        );
      }

      function isParentThreadMember() {
        let parentThread = get(/databases/$(database)/documents/task_threads/$(threadId));
        return isSignedIn() && (
          parentThread.data.customerId == request.auth.uid ||
          parentThread.data.helperId == request.auth.uid ||
          (parentThread.data.members is list &&
            parentThread.data.members.hasAny([request.auth.uid]))
        );
      }

      // PATCH START: Harden thread creation and fix list permissions
      function isCreatingOwnThread() {
        let members = request.resource.data.members;
        return isSignedIn()
          && members is list
          && members.size() == 2
          && request.auth.uid in members
          && members[0] != members[1]; // Prevent duplicate UIDs
      }
      
      // The `get` rule correctly ensures a user can only read threads they are a member of.
      // Firestore's query validation will leverage this `get` rule. When a client performs
      // a `list` query with `where('members', 'array-contains', request.auth.uid)`,
      // Firestore can prove that every document returned will pass the `get` rule.
      // Therefore, a simple `isSignedIn()` check on the `list` operation is sufficient and secure.
      allow list: if isSignedIn();
      // PATCH END

      allow get: if isThreadMember();
      allow create: if isCreatingOwnThread();
      allow update: if isThreadMember();
      allow delete: if false;

      match /messages/{messageId} {
        allow read: if isParentThreadMember();
        allow create: if isParentThreadMember()
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() <= 1500;
        allow update, delete: if false;
      }
    }
  }
}
